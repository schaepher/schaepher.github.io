# UML 课程




面向对象方法是一种运用对象、类、封装、继承、多态和消息等概念来构造、测试、重构软件的方法。

UML主要提供了五类十种图形:  
用例图(Use case diagram) 从用户角度描述系统功能,并指出各功能的操作者。  
静态图(Static diagram) 表示系统的静态结构,包括类图、对象图、包图。  
行为图(Behavior diagram) 描述系统的动态模型和组成对象间的交互关系。包括状态图、活动图。    
交互图(Interactive diagram) 描述对象间的交互关系。包括顺序图、合作图。    
实现图( Implementation diagram ) 用于描述系统的物理实现,包括构件图、配置图。  

面向对象的基本概念：  
对象是一个拥有属性,行为和标志符的实体  
 
方法的类型：属性过程，服务函数，接口函数，对象控制函数  
对象控制函数:实现对象生命周期的典型功能,控制对象的创建和销毁.
 
传统方法将数据和功能分开封装  
面向对象技术则是把功能和数据封装进入对象

类之间的关系：普通关联，层次结构

在类的继承层次结构中，位于较高抽象层次的类称为父类，位于较低抽象层次的类称为子类。

isa进行继承关系的测试  
an A(子类) is a B(父类) (A是一个B)

继承,重载,多态是为了提高系统的灵活性,降低类之间的耦合性

UML用例图中，用例之间的关系可分为：include，extend

活动图活动之间的连线表示：控制转移  
状态图状态之间的连线表示：动作

内部转移域是可选的。其中所列的动作将在对象处于该状态时执行且该动作的执行并不改变对象的状态。 

对象形式的设计模式一般采用组合/聚合的方法，而类形式的设计模式一般采用继承的方法。


什么是多继承？分析其利弊
什么是多态？
简单工厂模式解决什么问题？
什么是“面向接口编程”，分析其作用

适配器模式使用情况：
(1)系统需要使用现有的类，而此类的接口不符合系统的需要。  
(2)想要建立一个可以重复使用的类．用于一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有很复杂的接口。  
(3)(对对象的适配器模式而言)在设计里，需要改变多个已存在的子类的接口．如果使用类的适配器模式、就要针对每一个子类做一个适配器类，而这不太实际。  


##合成模式（树枝，树叶）：
在下面的情况下应当考虑使用合成模式：  
（1）需要描述对象的部分和整体的等级结构  
（2）需要客户端忽略掉整体构件和组合构件的区别。  

合成模式的优点：  
（1）可以很容易地增加新种类的构件  
（2）使客户端变得很容易设计，因为客户端不需知道是树叶还是树枝。  
   缺点：  
（1）确定树枝构件的接口不太容易  
（2）使用继承的方法来增加新的行为很困难。  


##装饰模式    
 优点:  
(1)装饰模式与继承关系的目的都是要扩展对象的功能,
但是装饰模式可以提供比继承更多的灵活性.  
---装饰模式允许系统动态地决定“贴上”一个需要的“装饰”,或者除掉一个不需要的“装饰”.继承关系则不同,继承关系是静态的,它在系统运行前就决定了.  
(2)通过使用不同的具体装饰类以及这些装饰类的排列组合,设计师可以创造出很多不同的行为的组合.  
(3)这种比继承更加灵活的特性；  

缺点:  
产生出较多的对象;  
比继承更易出错；  

##代理模式优缺点  

远程代理  
----可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的对象是局域的而不是远程的，而代理对象承担了大部分的网络通信工作。

 虚拟代理  
-----使用虚拟代理模式的优点就是代理对象可以在必要的时候才将被代理的对象加载。代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的时候，虚拟代理的优点就非常明显。

保护代理  
保护代理可以在运行时间对用户的有关权限进行检查，然后在核实后决定将调用传递给被代理的对象。

智能引用代理
在访问一个对象时可以执行一些内务处理（Housekeeping）操作，比如计数操作等。

##简单工厂模式  
优点：该模式的核心是工厂类。这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例（通过参数的传入）。而客户端则可以免除直接创建产品对象的责任，而仅仅负责“消费”产品。对于消费者角色来说，任何时候需要某种产品，只需要向工厂角色（下订单）请求即可，而无需知道产品创建细节。简单工厂模式通过这种做法实现了对责任的分割  

缺点：当产品类有复杂的多层次等级结构时，工厂类只有它自己。以不变应万变，就是模式的缺点。


##原型模式：  

通过复制（克隆）实现  

优点  
1、Prototype模式允许动态增加或减少产品类。由于创建产品类实例的方法是产品类内部具有的，因此增加新产品对整个结构没有影响。  
2、Prototype模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的等级结构，而Prototype模式就不需要这样。
3、Portotype模式具有给一个应用软件动态加载新功能的能力。由于Prototype的独立性较高，可以很容易动态加载新功能而不影响老系统。  
4、产品类不需要非得有任何事先确定的等级结构，因为Prototype模式适用于任何的等级结构。  

缺点
每一个类必须配备一个克隆方法。而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事

