<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Docker 介绍 - Schaepher's Blog</title><meta name=Description content="深透理解，熟练运用；似懂非懂，其实不懂。"><meta property="og:title" content="Docker 介绍"><meta property="og:description" content="Docker 是用来干嘛的？ 帮助开发者和系统管理员使用容器开发、部署和运行应用。 对于开发者而言，最直观的感受就是原先我们要跑起来一个已有项目，必须装一大"><meta property="og:type" content="article"><meta property="og:url" content="https://schaepher.github.io/2019/09/19/docker-series-e1/"><meta property="og:image" content="https://schaepher.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-19T19:32:00+00:00"><meta property="article:modified_time" content="2019-09-19T19:32:00+00:00"><meta property="og:site_name" content="Schaepher's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://schaepher.github.io/logo.png"><meta name=twitter:title content="Docker 介绍"><meta name=twitter:description content="Docker 是用来干嘛的？ 帮助开发者和系统管理员使用容器开发、部署和运行应用。 对于开发者而言，最直观的感受就是原先我们要跑起来一个已有项目，必须装一大"><meta name=application-name content="Schaepher's Blog"><meta name=apple-mobile-web-app-title content="Schaepher's Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://schaepher.github.io/2019/09/19/docker-series-e1/><link rel=prev href=https://schaepher.github.io/2019/09/19/docker-training/><link rel=next href=https://schaepher.github.io/2019/10/03/raspberry4b-nas/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker 介绍","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/schaepher.github.io\/2019\/09\/19\/docker-series-e1\/"},"genre":"posts","keywords":"Docker","wordcount":4844,"url":"https:\/\/schaepher.github.io\/2019\/09\/19\/docker-series-e1\/","datePublished":"2019-09-19T19:32:00+00:00","dateModified":"2019-09-19T19:32:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Schaepher"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Schaepher's Blog"></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/>主页 </a><a class=menu-item href=/posts/ title=文章按年份分类>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Schaepher's Blog"></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/ title>主页</a><a class=menu-item href=/posts/ title=文章按年份分类>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Docker 介绍</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://cnblogs.com/schaepher title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Schaepher</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/learning-docker/><i class="far fa-folder fa-fw" aria-hidden=true></i>Learning Docker</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2019-09-19>2019-09-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 4844 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 10 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#docker-是用来干嘛的>Docker 是用来干嘛的？</a></li><li><a href=#docker-和虚拟机的区别>Docker 和虚拟机的区别</a></li><li><a href=#docker-基于什么样的技术>Docker 基于什么样的技术</a></li><li><a href=#hello-world>Hello World</a></li><li><a href=#轻量基础镜像-alpine>轻量基础镜像 Alpine</a></li><li><a href=#镜像层和容器层>镜像层和容器层</a></li><li><a href=#如何保持运行状态>如何保持运行状态？</a></li><li><a href=#定制镜像>定制镜像</a></li><li><a href=#使用-dockerfile-基于基础镜像构建新镜像>使用 Dockerfile 基于基础镜像构建新镜像</a></li><li><a href=#端口映射>端口映射</a></li><li><a href=#数据卷映射>数据卷映射</a></li><li><a href=#更多的-dockerfile-构建命令>更多的 Dockerfile 构建命令</a></li><li><a href=#直观地感受-docker-资源>直观地感受 Docker 资源</a></li></ul></nav></div></div><div class=content id=content><h2 id=docker-是用来干嘛的>Docker 是用来干嘛的？</h2><p>帮助开发者和系统管理员使用容器开发、部署和运行应用。</p><p>对于开发者而言，最直观的感受就是原先我们要跑起来一个已有项目，必须装一大堆依赖。<br>在没有 Docker 的时候，可以有两种方式：</p><ol><li>写一个自动化脚本。安装的时候去执行这个脚本。</li><li>将依赖安装到虚拟机，导出镜像。需要的时候去下载镜像。</li></ol><p>第一种方式可能会因为网络原因或者版本变更导致安装失败。第二种方式的虚拟机会占用大量资源，而且使用上还要对虚拟机做配置。</p><p>而如果使用 Docker，这些依赖的安装命令将会由运维人员定义在一个脚本（Dockerfile）。并且通过脚本构建镜像。开发人员安装 Docker 引擎后，拉取镜像并运行。</p><p>跟虚拟机很像，但是也有区别。</p><h2 id=docker-和虚拟机的区别>Docker 和虚拟机的区别</h2><p>主要有两点：宿主机磁盘占用和资源占用</p><p>先说宿主机磁盘占用：</p><p>虚拟机由于包含了一个完整的系统，因此镜像会比较大。例如 CentOS 7 的镜像大小为 1GB 左右。</p><blockquote><p>CentOS 7 虚拟机镜像下载地址：<br><a href=https://www.osboxes.org/centos/ target=_blank rel="noopener noreffer">https://www.osboxes.org/centos/</a></p></blockquote><p>而 CentOS 7 的 Docker 镜像大小为：70 MB 左右。</p><blockquote><p>CentOS 7 的 Docker 镜像：<br><a href="https://hub.docker.com/_/centos?tab=tags" target=_blank rel="noopener noreffer">https://hub.docker.com/_/centos?tab=tags</a></p></blockquote><p>能否再小一点？能！Alpine 镜像的大小不到 3 MB。</p><blockquote><p>Alpine 的 Docker 镜像：<br><a href="https://hub.docker.com/_/alpine?tab=tags" target=_blank rel="noopener noreffer">https://hub.docker.com/_/alpine?tab=tags</a></p></blockquote><p>再从复用性来讲。每启动一个新的虚拟机，就得再消耗一份镜像大小的空间。而每启动一个 Docker 容器，就只需要加一个容器层。这个我们后面再说。</p><p>从资源占用的角度讲两者的区别：</p><p>由于虚拟机是装一个完整的系统，因此系统内核的运行消耗会增加宿主机的资源消耗。另外一个显著的问题就是系统启动时，很慢。可达分钟级别。<br>在分配资源时，虚拟机需要通过一个虚拟机管理系统(Hypervisor)分配硬件资源。</p><p>而 Docker 镜像不是一个完整的操作系统，它使用宿主机的内核。Docker 容器的启动时间是秒级别，甚至可以是毫秒级别。<br>Docker 容器的资源分配是通过 Docker 直接向宿主机获取的。</p><p>虚拟机：[ App -> Bins/Libs -> Guest OS ] -> Hypervisor -> Host OS -> Infrastructure<br>Docker：[ App -> Bins/Libs ] -> Docker -> Host OS -> Infrastructure</p><p>你甚至可以在镜像内只安装一个小应用，然后把这个镜像当做一个软件。</p><h2 id=docker-基于什么样的技术>Docker 基于什么样的技术</h2><p>Linux Kernel 3.10+：Namespace 和 Control Groups<br>Windows 10：Hyper-V</p><p>Docker 现在要求如果是 Linux 系统，内核版本要大于 3.10。对应就是 CentOS 7。如果感兴趣我们可以讲讲为什么。</p><p>Docker 用到的 Linux 内核技术是命名空间（Namespace）和控制组（Control Groups）。总结起来就是资源隔离和资源控制。</p><ul><li><p>命名空间就跟我们 Java 包名或者 C++ 和 PHP 里面的那个命名空间有点相似。<br>命名空间可以隔离系统资源，包括：文件系统挂接点、nodename 和 domainname、进程间通信资源、进程 ID 数字空间 、网络相关的系统资源、用户和组 ID 空间。<br>举个例子，在各个容器里面都可以有进程号为 1 的 root 进程。就像不同命名空间可以有同名的类。<br>但不同的是，这里的命名空间还使得处于不同空间的对象无法直接互相访问。这样就提供了一定程度的安全性。</p></li><li><p>控制组的功能包括对硬件资源的：资源限制、优先级分配、资源统计、进程控制。</p></li></ul><h2 id=hello-world>Hello World</h2><p>我们试着下载镜像并启动。</p><p>执行命令：<br><code>docker run hello-world</code></p><p>会有以下输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Unable to find image &#39;hello-world:latest&#39; locally
</span></span><span class=line><span class=cl>latest: Pulling from library/hello-world
</span></span><span class=line><span class=cl>1b930d010525: Pull complete 
</span></span><span class=line><span class=cl>Digest: sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00
</span></span><span class=line><span class=cl>Status: Downloaded newer image for hello-world:latest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hello from Docker!
</span></span><span class=line><span class=cl>This message shows that your installation appears to be working correctly.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To generate this message, Docker took the following steps:
</span></span><span class=line><span class=cl> 1. The Docker client contacted the Docker daemon.
</span></span><span class=line><span class=cl> 2. The Docker daemon pulled the &#34;hello-world&#34; image from the Docker Hub.
</span></span><span class=line><span class=cl>    (amd64)
</span></span><span class=line><span class=cl> 3. The Docker daemon created a new container from that image which runs the
</span></span><span class=line><span class=cl>    executable that produces the output you are currently reading.
</span></span><span class=line><span class=cl> 4. The Docker daemon streamed that output to the Docker client, which sent it
</span></span><span class=line><span class=cl>    to your terminal.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To try something more ambitious, you can run an Ubuntu container with:
</span></span><span class=line><span class=cl> $ docker run -it ubuntu bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Share images, automate workflows, and more with a free Docker ID:
</span></span><span class=line><span class=cl> https://hub.docker.com/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>For more examples and ideas, visit:
</span></span><span class=line><span class=cl> https://docs.docker.com/get-started/
</span></span></code></pre></td></tr></table></div></div><p>执行 run 的时候，Docker 会在本地找 hello-world 镜像。由于我们没有指定镜像版本，因此默认使用 latest 版本。<br>接着因为 Docker 没有找到要执行的镜像，它会到远程镜像仓库里面找这个镜像。如果找到镜像，则下载并执行；找不到就报错。</p><p><a href=https://github.com/docker-library/hello-world target=_blank rel="noopener noreffer">https://github.com/docker-library/hello-world</a></p><p><a href=https://github.com/docker-library/hello-world/blob/master/arm64v8/hello-world/Dockerfile target=_blank rel="noopener noreffer">https://github.com/docker-library/hello-world/blob/master/arm64v8/hello-world/Dockerfile</a></p><p><a href=https://github.com/docker-library/hello-world/blob/master/hello.c target=_blank rel="noopener noreffer">https://github.com/docker-library/hello-world/blob/master/hello.c</a></p><h2 id=轻量基础镜像-alpine>轻量基础镜像 Alpine</h2><p>前面提到 Alpine 的大小只有 3 MB。如果想尽可能地使构建出来的镜像小的话，则优先考虑使用 Alpine。</p><p>如果能够确定不需要依赖于任何系统，连这 3 MB 都省去。例如前面一节的 hello-world 就不基于任何基础镜像，但是这样一来就得自己做好安全控制和增加必要的便捷性。除非必要，否则都会基于一个基础镜像。</p><p>拉取 Alpine 镜像：<br><code>docker pull alpine</code></p><p>如果你 run 这个 alpine，它会立即退出。因为没有什么命令使得它必须处于运行状态。</p><blockquote><p>如何使它保持运行状态？等说完镜像层和容器层，会详细说明。</p></blockquote><p>你可以把它当成一个执行 Linux 命令的工具：<br><code>docker run alpine echo "hello"</code></p><p>如果你想要有交互，可以加上 <code>-it</code>：<br><code>docker run -it alpine sh</code></p><p>这样就进入了交互状态，就好像进入了另一台机器。</p><p>关于 <code>-it</code> 选项：</p><p><code>-i</code> 是 &ndash;interactive 的缩写，表示将当前输入连接到容器执行的进程的标准输入（STDIN）里面。<br><code>-t</code> 是 &ndash;tty 的缩写。表示申请一个伪终端（PTY），并连接到容器。可以接受 STDOUT 和 STDERR。</p><blockquote><p>关于 i 和 t 的详细解释见：<br><a href=https://stackoverflow.com/questions/30137135/confused-about-docker-t-option-to-allocate-a-pseudo-tty/54254380#54254380 target=_blank rel="noopener noreffer">https://stackoverflow.com/questions/30137135/confused-about-docker-t-option-to-allocate-a-pseudo-tty/54254380#54254380</a></p></blockquote><p>当你执行 exit 退出时，容器就结束了。</p><h2 id=镜像层和容器层>镜像层和容器层</h2><p>先说镜像层。</p><p>一个镜像通常由多个只读（read only）的镜像层组成，每个镜像层表示构建这个镜像时的每一步操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+------------------------+
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|  Image Layer 1 (ro)    |
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>+------------------------+
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|  Image Layer 2 (ro)    |
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>+------------------------+
</span></span></code></pre></td></tr></table></div></div><p>执行 run 的时候，发生了什么？</p><p>run 包含了两个步骤：create 和 start。如果还加了 -i -t 两个参数，那还有第三个步骤 attach。</p><ol><li>create 时， Docker 会在镜像的基础上创建一个可读写(read and write)的容器层。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+------------------------+
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|  Container Layer (rw)  |
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>+------------------------+
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|  Image Layer 1 (ro)    |
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>+------------------------+
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|  Image Layer 2 (ro)    |
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>+------------------------+
</span></span></code></pre></td></tr></table></div></div></li><li>start 启动容器。可以加入 -i -a 来进入交互模式。-i 会连接标准输入，-a 会连接标准输出和标准错误。</li><li>attach 会将你的终端接入正在执行中的容器，连接到标准输入输出和错误。STDIN,STDOUT,STDERR。</li></ol><p>创建多少容器，就有多少份容器层。但它们没有依赖关系，共用镜像。<br>当我们销毁容器的时候，会把这一个读写层完全删除。里面的数据会全部被删除掉（这点很重要）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+------------------------+   +------------------------+   +------------------------+
</span></span><span class=line><span class=cl>|                        |   |                        |   |                        |
</span></span><span class=line><span class=cl>|  Container Layer (rw)  |   |  Container Layer (rw)  |   |  Container Layer (rw)  |
</span></span><span class=line><span class=cl>|                        |   |                        |   |                        |
</span></span><span class=line><span class=cl>+------------------------+   +------------------------+   +------------------------+
</span></span><span class=line><span class=cl>           X                             X                            X
</span></span><span class=line><span class=cl>           XXXXXXXXXXXXXXXXXXXXXXX       X        XXXXXXXXXXXXXXXXXXXXX
</span></span><span class=line><span class=cl>                                 X       X        X
</span></span><span class=line><span class=cl>                                 X       X        X
</span></span><span class=line><span class=cl>                             +------------------------+
</span></span><span class=line><span class=cl>                             |                        |
</span></span><span class=line><span class=cl>                             |  Image Layer 1 (ro)    |
</span></span><span class=line><span class=cl>                             |                        |
</span></span><span class=line><span class=cl>                             +------------------------+
</span></span><span class=line><span class=cl>                             |                        |
</span></span><span class=line><span class=cl>                             |  Image Layer 2 (ro)    |
</span></span><span class=line><span class=cl>                             |                        |
</span></span><span class=line><span class=cl>                             +------------------------+
</span></span></code></pre></td></tr></table></div></div><h2 id=如何保持运行状态>如何保持运行状态？</h2><p>当从镜像创建容器后，这个容器相当于一个程序。你执行这个程序，等执行完后，它就退出了。就像最开始的 hello-world ，当它打印完说明后，就结束了。然后容器退出。</p><p>我们在创建容器的时候，会指定一个程序来执行。启动容器时，会启动这个程序，分配一个进程（主进程）。容器将会跟踪这个进程的状态。</p><p>当进程退出时，容器也会随之退出。例如我们在执行 <code>docker run -it alpine sh</code> 后进入了 sh 的交互状态。当我们继续执行 exit 时，退出了 sh 的进程，容器也跟着退出了。</p><p>如果想让容器不退出，就得将进程保持在执行状态，不让它退出。</p><p>最简单的一种方式就是让容器启动时执行 <code>tail -f /dev/null</code> 这个命令。这个命令表示不断读取 <code>/dev/null</code>，这样它永远都不会退出，并且不会产生多余的输出。</p><p>但是如果所有的镜像都指定容器启动时执行上面这个命令，那就不合适了。</p><p>这是由于我们让容器提供的服务有可能会因为各种异常而退出，这时我们希望它可以自动重启。</p><p>我们可以让 Docker 在发现容器退出时自动重启容器，但是 <code>tail -f /dev/null</code> 这个命令使得容器不会因为其他进程的退出而退出。</p><p>后面会详细说明其他保活方法。</p><h2 id=定制镜像>定制镜像</h2><p>上文在对比 Docker 和虚拟机的时候说过。虚拟机可以进入安装所有依赖，然后保存镜像。Docker 也可以。Docker 可以将容器层（可读写）转换为镜像层（只读）。</p><p>我们可以通过 <code>docker run -it alpine sh</code> 进入 alpine ，然后做一些依赖的安装操作。</p><p>这里举个不是安装依赖的简单例子：在 home 底下创建一个 test 文件夹。然后退出。</p><p>如果你再执行 <code>docker run -it alpine sh</code> 进入 alpine 。你会发现这个文件夹不在了。在【镜像层和容器层】这一节有提到，每次 run 都会生成新的容器。</p><p>该如何找到刚刚创建的容器？可以用 <code>docker ps -a</code>。-a 表示显示所有容器，包括启动的和已退出的。因为我们没有给容器加上保活的机制，所以在退出主进程的时候就会变为退出状态。</p><p>如果我们想把对这个容器的更改保存起来，防止被删除，可以执行：</p><p><code>docker commit &lt;container-id> &lt;tag></code></p><p>例如对 id 为 33ebad6f23d5 的容器，在宿主机执行：</p><p><code>docker commit 33ebad6f23d5 test</code></p><p>然后再去 run 这个名字为 tag 的新镜像，就可以在 home 底下看到 test 文件夹了。</p><p><code>docker run test ls /home</code></p><h2 id=使用-dockerfile-基于基础镜像构建新镜像>使用 Dockerfile 基于基础镜像构建新镜像</h2><p>使用 commit 定制镜像有一个问题。</p><p>通过 <code>docker history 镜像名</code> 来查看上一节中 commit 的镜像的历史，可以看到最顶层是这样的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
</span></span><span class=line><span class=cl>25b2ad442d41        6 days ago          sh                                              31 B                
</span></span></code></pre></td></tr></table></div></div><p>这样看不出来这一层究竟执行了哪些命令，增加了维护的难度。</p><p>有的同学就会说了：那写到脚本里面不就行了？</p><p>写到脚本里面也是可以的，但这不是最优的做法。</p><p>在【镜像层和容器层】一节中，我们知道镜像是分层的。这样做有什么好处呢？</p><ol><li>当 Docker 直到你即将构建的这一层与原先已构建的一层所执行的命令一样，那它就直接使用原先的镜像层。这样加快了构建的速度。</li><li>当镜像传输时，本地已有的镜像层不会再下载。加快了镜像下载的速度。<br>比如你已经下载了一个最新版的 alpine 镜像，然后又下载两个都是基于当前最新版本的 alpine 构建的镜像。那么下载的时候会跳过 alpine 镜像的下载。</li></ol><p>如果使用脚本去构建，总是会只生成一层镜像层。那么每次构建时都得从头开始。传输时也是全部重新传一次。</p><p>我们可以像写 bash 脚本那样把命令都放在一个文件。这就是 Dockerfile。</p><p>在使用 Dockerfile 构建镜像时，FROM 以外的命令都会生成一个镜像层。这样就能享受到分层的好处了。</p><p>对于刚才使用 commit 的定制，我们可以换成 Dockerfile 的方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> alpine:latest</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir /home/test<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这样我们就可以通过查看这个文件得知这个镜像都做了哪些修改。</p><p>这里的 FROM 的意思是基于哪个镜像。在那个镜像上执行操作。</p><p>RUN 后面跟上相关命令。</p><p>文件以 Dockerfile 为名并保存。然后在宿主机执行构建：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># docker build . -t testv2
</span></span><span class=line><span class=cl>Sending build context to Docker daemon  2.048kB
</span></span><span class=line><span class=cl>Step 1/2 : FROM alpine:latest
</span></span><span class=line><span class=cl> ---&gt; 965ea09ff2eb
</span></span><span class=line><span class=cl>Step 2/2 : RUN mkdir /home/test
</span></span><span class=line><span class=cl> ---&gt; Running in e2548722ecbe
</span></span><span class=line><span class=cl>Removing intermediate container e2548722ecbe
</span></span><span class=line><span class=cl> ---&gt; 9678e6e6b110
</span></span><span class=line><span class=cl>Successfully built 9678e6e6b110
</span></span><span class=line><span class=cl>Successfully tagged testv2:latest
</span></span></code></pre></td></tr></table></div></div><p>从 Step 1/2 可以看到使用的基础镜像 ID 为 965ea09ff2eb。</p><p>从 Step 2/2 可以看到 Docker 在构建镜像的时候启动了一个容器 e2548722ecbe，然后执行 <code>mkdir /home/test</code>。在 commit 后生成镜像 9678e6e6b110，并且删除刚刚创建的容器 e2548722ecbe。</p><p>镜像已经创建了。由于执行构建的时候，还指定了镜像的 tag，因此会将 9678e6e6b110 的名称设置为 <code>testv2:latest</code>。</p><p>执行下面的命令可以看到镜像 testv2 在 home 底下有个 test 文件夹：</p><p><code>docker run testv2 ls /home</code></p><h2 id=端口映射>端口映射</h2><p>由于命名空间对网络资源的隔离，宿主机无法直接访问容器内进程的端口。</p><p>我们要做的就是分配一个宿主机的端口，让它与容器的端口关联起来。</p><p>下面的命令将宿主机的 60044 端口与容器的 80 端口关联起来：</p><p><code>docker run -d -p 60044:80 nginx:alpine</code></p><p>这样当我们访问宿主机的 60044 端口时，就相当于在访问容器的 80 端口。</p><p>有的同学会问：那我多个容器内部能不能使用一样的端口？比如启动两个 nginx 容器，都监听 80 端口。</p><p>当然可以。由于命名空间对网络资源的隔离，容器之间使用的端口都不影响。但是当它们与宿主机端口建立关联时，不能使用同一个宿主机端口。</p><p>有时候下载了一个镜像，不知道这个镜像的作者提供了哪些可用的端口怎么办？</p><p>可以找到构建这个镜像的 Dockerfile，里面会有 EXPOSE 命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>EXPOSE</span><span class=s> 80</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>EXPOSE 仅用于提示使用该 Dockerfile 构建出的镜像的用户有哪些端口可以映射，它不会自己映射端口。</p><p>没有 Dockerfile 怎么办？<code>docker history 镜像名</code>。</p><h2 id=数据卷映射>数据卷映射</h2><p>在【镜像层和容器层】一节提到，删除容器时会把容器里面的数据全删除掉。那么如何才能让想要的数据不被删除呢？</p><p>可以选择映射到宿主机的目录或者放到数据卷里面。</p><p>你可以把数据卷想象成一个专门存放数据的空间，将多个数据卷挂载到容器的不同目录下。容器被删除时，这些数据卷不会被删除。</p><p>执行 <code>docker volume create 数据卷名称</code> 来创建数据卷。然后执行下面命令将数据卷映射到 <code>/home/test</code>。</p><p><code>docker run -it -v 数据卷名称:/home/test testv2 sh</code></p><p>其中第一步创建数据卷可以省略，第二步在数据卷未创建时，会自动创建。</p><p>下面命令将当前所在的宿主机目录映射到容器的 <code>/home/test</code> 目录。</p><p><code>docker run -it -v "${PWD}:/home/test" testv2 sh</code></p><p><code>${PWD}</code> 可以替换为相对路径或者绝对路径。</p><p>Dockerfile 的 VOLUME 类似于 EXPOSE：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>VOLUME</span><span class=s> /home/test</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>但它不仅有提示用户的作用。如果用户没有在创建容器的时候指定映射目标，它会创建一个随机命名的数据卷，并挂载到 /home/test。</p><h2 id=更多的-dockerfile-构建命令>更多的 Dockerfile 构建命令</h2><p>看另一篇： <a href=https://schaepher.github.io/2018/12/09/dockerfile/ target=_blank rel="noopener noreffer">Dockerfile</a></p><h2 id=直观地感受-docker-资源>直观地感受 Docker 资源</h2><p>Docker 的数据存放在一个特定的目录里面。例如 CentOS 7 的 Docker 数据默认存放在 <code>/var/lib/docker</code> 里面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># ls /var/lib/docker
</span></span><span class=line><span class=cl>builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes
</span></span></code></pre></td></tr></table></div></div><p>之前创建的数据卷在 volumes 里面。</p><p>这个存放位置可以更改（这在将树莓派作为 NAS 的时候非常有用）：</p><p>vim /etc/docker/daemon.json</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data-root&#34;</span><span class=p>:</span> <span class=s2>&#34;/mnt/docker-data&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2019-09-19</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/2019/09/19/docker-series-e1/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://schaepher.github.io/2019/09/19/docker-series-e1/ data-title="Docker 介绍" data-hashtags=Docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://schaepher.github.io/2019/09/19/docker-series-e1/ data-hashtag=Docker><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://schaepher.github.io/2019/09/19/docker-series-e1/ data-title="Docker 介绍"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://schaepher.github.io/2019/09/19/docker-series-e1/ data-title="Docker 介绍"><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://schaepher.github.io/2019/09/19/docker-series-e1/ data-title="Docker 介绍"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://schaepher.github.io/2019/09/19/docker-series-e1/ data-title="Docker 介绍"><i class="fab fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2019/09/19/docker-training/ class=prev rel=prev title="Docker 介绍"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Docker 介绍</a>
<a href=/2019/10/03/raspberry4b-nas/ class=next rel=next title="树莓派4B + CentOS 7 + Nextcloud">树莓派4B + CentOS 7 + Nextcloud<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://cnblogs.com/schaepher target=_blank>Schaepher</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>