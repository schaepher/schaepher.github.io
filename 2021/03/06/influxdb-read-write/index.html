<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>InfluxDB 存储结构、读、写 - Schaepher's Blog</title><meta name=Description content="深透理解，熟练运用；似懂非懂，其实不懂。"><meta property="og:title" content="InfluxDB 存储结构、读、写"><meta property="og:description" content="这篇最早是 2021 年 3 月写的，最近又拿出来复习一遍，也补充了一些新的内容。上一篇博客发表过后已经 3 个月没有发表新的博客，就把这篇拿出来了。内容没有"><meta property="og:type" content="article"><meta property="og:url" content="https://schaepher.github.io/2021/03/06/influxdb-read-write/"><meta property="og:image" content="https://schaepher.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-06T00:00:00+00:00"><meta property="og:site_name" content="Schaepher's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://schaepher.github.io/logo.png"><meta name=twitter:title content="InfluxDB 存储结构、读、写"><meta name=twitter:description content="这篇最早是 2021 年 3 月写的，最近又拿出来复习一遍，也补充了一些新的内容。上一篇博客发表过后已经 3 个月没有发表新的博客，就把这篇拿出来了。内容没有"><meta name=application-name content="Schaepher's Blog"><meta name=apple-mobile-web-app-title content="Schaepher's Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://schaepher.github.io/2021/03/06/influxdb-read-write/><link rel=prev href=https://schaepher.github.io/2021/02/23/concurrency-parallelism-and-lock/><link rel=next href=https://schaepher.github.io/2021/03/06/pcb/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"InfluxDB 存储结构、读、写","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/schaepher.github.io\/2021\/03\/06\/influxdb-read-write\/"},"genre":"posts","keywords":"InfluxDB","wordcount":4763,"url":"https:\/\/schaepher.github.io\/2021\/03\/06\/influxdb-read-write\/","datePublished":"2021-03-06T00:00:00+00:00","dateModified":"2021-03-06T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Schaepher"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Schaepher's Blog"></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/>主页 </a><a class=menu-item href=/posts/ title=文章按年份分类>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Schaepher's Blog"></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/ title>主页</a><a class=menu-item href=/posts/ title=文章按年份分类>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">InfluxDB 存储结构、读、写</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://cnblogs.com/schaepher title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Schaepher</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/database/><i class="far fa-folder fa-fw" aria-hidden=true></i>Database</a>&nbsp;<a href=/categories/influxdb/><i class="far fa-folder fa-fw" aria-hidden=true></i>InfluxDB</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-03-06>2021-03-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 4763 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 10 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#基础概念>基础概念</a></li><li><a href=#influxdb-是怎么读取一行数据的>influxDB 是怎么读取一行数据的？</a><ul><li><a href=#iterator-是如何工作的>Iterator 是如何工作的？</a></li><li><a href=#嵌套的-iterator-是如何配合的>嵌套的 Iterator 是如何配合的？</a></li><li><a href=#一行的数据是如何合并的>一行的数据是如何合并的？</a></li><li><a href=#集群应该如何处理>集群应该如何处理？</a></li></ul></li><li><a href=#influxdb-是怎么存储数据的>influxDB 是怎么存储数据的？</a></li><li><a href=#连续查询continues-query>连续查询（Continues Query）</a></li><li><a href=#写入>写入</a></li><li><a href=#写入的优化>写入的优化</a></li><li><a href=#series-file>Series File</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>这篇最早是 2021 年 3 月写的，最近又拿出来复习一遍，也补充了一些新的内容。上一篇博客发表过后已经 3 个月没有发表新的博客，就把这篇拿出来了。内容没有完全梳理完毕，算是笔记。先发出来，后续再逐渐完善。</p></blockquote><p>InfluxDB 是开源的时序数据库，采用列式存储。原先有开源集群版本，但在 0.11 版本之后，集群版本仅在商业版中提供。</p><p>在一些场景中，需要用到集群，但又不需要完整的集群功能，只需要简单地实现分片存储和查询或者副本集就行了。可以在开源的基础上添加这些简单的功能。</p><p>添加功能的方式可以分为通过顶层的 HTTP API 操作和参考 InfluxDB 源码写相应扩展。</p><p>例如通过 HTTP API 写入数据时可以通过 Nginx 的一致性 hash 将数据转发到不同的 InfluxDB 实例，用 HTTP API 把请求发送到所有 InfluxDB 然后手动合并，或者写个中间层合并。但是资源消耗比较大，而且不够灵活。因此很有必要了解 InfluxDB 的源码。</p><p>一个系统的发展通常是越来越复杂，并且这个过程中的代码会受到其发展过程中的影响。选择一个合适的版本就行了。这里选择的是 0.11.1 版本的代码。按照惯例，省略的代码用 <code>// ...</code> 代替。</p><h2 id=基础概念>基础概念</h2><p>InfluxDB 的 measurement 类似关系数据库的 table，Point 类似关系数据库的行，存储着某一时刻的数据。Point 的接口定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Point</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Measurement 部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Name</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nf>SetName</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Tag 部分
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Tags</span><span class=p>()</span> <span class=nx>Tags</span>
</span></span><span class=line><span class=cl>	<span class=nf>AddTag</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>SetTags</span><span class=p>(</span><span class=nx>tags</span> <span class=nx>Tags</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Field 部分
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Fields</span><span class=p>()</span> <span class=nx>Fields</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Timestamp 部分
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Time</span><span class=p>()</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>	<span class=nf>SetTime</span><span class=p>(</span><span class=nx>t</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>UnixNano</span><span class=p>()</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Measurement + Tags
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Key</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Point 有四大块：</p><ul><li>Measurement：类似于表。</li><li>Tag：起到索引的作用。标签可以有多个，每个标签是一个 <code>key,value</code> 映射。</li><li>Field：字段，具体的值。</li><li>Timestamp：时间点。</li></ul><p>这四块中，Measurement 和 Tag 组成了 Series，类似于一个集合。由于 Series 没有 Timestamp 维度，因此一个 Series 底下有多个时间点的数据，也就意味着有多个 Point。</p><p>Series 的 key 由一个 measurement 名称、 多个 <code>tag_key=tag_value</code> 组成，例如 <code>series.Key = "cpu,host=A"</code>。</p><h2 id=influxdb-是怎么读取一行数据的>influxDB 是怎么读取一行数据的？</h2><ul><li>从查询语句中解析出所有 field</li><li>找到这些 field 的类型对应的 iterator</li><li>根据查询语句对 field 的要求（例如聚合），用装饰模式创建对应的 iterator，包裹底层的 iterator。</li><li>由 Emitter 来调用 iterator 读取数据<ul><li>遍历所有 iterator，读取每个字段的下一个数据，放到 buffer 里面。buffer 是一个数组，按照顺序存放每个 iterator 的结果。</li><li>这次读取时的【时间、measurement、tags】会发生变化，作为 row 的 key。</li><li>如果读取后在 buffer 里面找不到这个 key，则创建一个 row；如果存在，则加入这次读的数据。</li></ul></li></ul><p>集群在查询时，用了一层 remoteIteratorCreator，来读取远程 shard 的数据。</p><p>底层的 iterator 在 <code>tsdb/engine/tsm1/engine.go</code> 里面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// buildIntegerCursor creates a cursor for an integer field.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>buildIntegerCursor</span><span class=p>(</span><span class=nx>measurement</span><span class=p>,</span> <span class=nx>seriesKey</span><span class=p>,</span> <span class=nx>field</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>opt</span> <span class=nx>influxql</span><span class=p>.</span><span class=nx>IteratorOptions</span><span class=p>)</span> <span class=nx>integerCursor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cacheValues</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>Cache</span><span class=p>.</span><span class=nf>Values</span><span class=p>(</span><span class=nf>SeriesFieldKey</span><span class=p>(</span><span class=nx>seriesKey</span><span class=p>,</span> <span class=nx>field</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>keyCursor</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.</span><span class=nf>KeyCursor</span><span class=p>(</span><span class=nf>SeriesFieldKey</span><span class=p>(</span><span class=nx>seriesKey</span><span class=p>,</span> <span class=nx>field</span><span class=p>),</span> <span class=nx>opt</span><span class=p>.</span><span class=nf>SeekTime</span><span class=p>(),</span> <span class=nx>opt</span><span class=p>.</span><span class=nx>Ascending</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>newIntegerCursor</span><span class=p>(</span><span class=nx>opt</span><span class=p>.</span><span class=nf>SeekTime</span><span class=p>(),</span> <span class=nx>opt</span><span class=p>.</span><span class=nx>Ascending</span><span class=p>,</span> <span class=nx>cacheValues</span><span class=p>,</span> <span class=nx>keyCursor</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=iterator-是如何工作的>Iterator 是如何工作的？</h3><p>举一个 sum 的例子。</p><p>sum 是函数，在 <code>influxql/call_iterator.go</code> 里面由 <code>NewCallIterator</code> 创建 <code>integerReduceIntegerIterator</code> 或者 <code>floatReduceFloatIterator</code>。</p><blockquote><p>由于 InfluxDB 的数据类型只有四种：浮点数、整数、字符串和布尔值，所以仅需要支持浮点数和整数。</p></blockquote><p>以 <code>integerReduceIntegerIterator</code> 为例。</p><p>对于要合并的数据，两者的 field_key 和 tags 是一致的，这样可以生成一个唯一 key。对于每个 key，生成一个对应的 <code>integerReduceIntegerPoint</code>。</p><p><code>integerReduceIntegerPoint</code> 保存了一个 value，放在 prev 结构体里面。每次得到一个相同 key 的时候，获取 <code>integerReduceIntegerPoint</code>，并将当前值与 prev 的值相加，并保存到 prev 里面。在对上一个阶段的结果集做一遍这个合并后，得到一批 IntegerPoint，并从大到小排序。每次 Next() 从中取最后一个。</p><h3 id=嵌套的-iterator-是如何配合的>嵌套的 Iterator 是如何配合的？</h3><p>假设有 IteratorB(IteratorA) 这样的嵌套。</p><p>每次 IteratorB 执行 Next() 的时候，会先执行一次 reduce()，目的是合并或过滤掉符合条件的相邻的数据。它会去找 IteratorA 获取一个时间段的所有数据，然后将这些数据转换为只剩下一条。</p><h3 id=一行的数据是如何合并的>一行的数据是如何合并的？</h3><p>【时间、measurement、tags】 每次读取的时候都有可能发生变化。这是因为每个字段虽然是按照时间顺序读取，但某一时刻，不一定所有的字段都有值，此时读取的是指定时刻之后的数据。</p><p>这样一个 buffer 中，各个字段的时间可能不一致。如果查询语句是按时间增序，则取时间最小的那个字段。以这个字段的 【时间、measurement、tags】 去 buffer 中找相匹配的 field。以此组合成 row。</p><p>字段的顺序怎么办？字段的顺序在一开始创建 iterator 集合的时候就固定了。每次读取的时候都是按照 iterator 的顺序读取。在组合 row 的时候，如果一个 iterator 的数据不能满足 【时间、measurement、tags】，则其对应的下标的值为 nil。</p><h3 id=集群应该如何处理>集群应该如何处理？</h3><p>集群使用 remoteIteratorCreator，它会创建 ReaderIterator，从 <code>io.Reader</code> 里读取数据。这个 <code>io.Reader</code> 是一个 TCP 连接。</p><p>根据 select 指定的时间范围，找到时间范围内的所有 shard 及其所在的集群节点。然后对每个节点都建立一个连接。</p><h2 id=influxdb-是怎么存储数据的>influxDB 是怎么存储数据的？</h2><blockquote><p>存储格式：<br><a href=http://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one target=_blank rel="noopener noreffer">http://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one</a></p></blockquote><p>在启动后，会定期检查是否应该将缓存中的数据刷入到磁盘中。</p><p>数据文件是 tsm 类型。整个文件包含四个部分：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌────────┬────────────────────────────────────┬─────────────┬──────────────┐
</span></span><span class=line><span class=cl>│ Header │               Blocks               │    Index    │    Footer    │
</span></span><span class=line><span class=cl>│5 bytes │              N bytes               │   N bytes   │   4 bytes    │
</span></span><span class=line><span class=cl>└────────┴────────────────────────────────────┴─────────────┴──────────────┘
</span></span></code></pre></td></tr></table></div></div><p>Blocks 存储着实际数据。每个 Block 表示一批 series + field 相同且经过压缩后的数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>┌────────┬────────────────────────────────────┬─────────────┬──────────────┐
</span></span><span class=line><span class=cl>│ Header │               Blocks               │    Index    │    Footer    │
</span></span><span class=line><span class=cl>│5 bytes │              N bytes               │   N bytes   │   4 bytes    │
</span></span><span class=line><span class=cl>└────────┴────────────────────────────────────┴─────────────┴──────────────┘
</span></span><span class=line><span class=cl>                            ↑ 取这个部分得到下图
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>┌───────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                          Blocks                           │
</span></span><span class=line><span class=cl>└───────────────────────────────────────────────────────────┘
</span></span><span class=line><span class=cl>                              ↓ 切割
</span></span><span class=line><span class=cl>┌───────────────────┬───────────────────┬───────────────────┐
</span></span><span class=line><span class=cl>│      Block 1      │      Block 2      │      Block N      │
</span></span><span class=line><span class=cl>└───────────────────┴───────────────────┴───────────────────┘
</span></span><span class=line><span class=cl>                              ↓ 切割
</span></span><span class=line><span class=cl>┌─────────┬─────────┬───────────────────┬─────────┬─────────┐
</span></span><span class=line><span class=cl>│  CRC    │  Data   │  CRC    │  Data   │  CRC    │  Data   │
</span></span><span class=line><span class=cl>│ 4 bytes │ N bytes │ 4 bytes │ N bytes │ 4 bytes │ N bytes │
</span></span><span class=line><span class=cl>└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</span></span></code></pre></td></tr></table></div></div><p>在向 InfluxDB insert 多条数据的时候， InfluxDB 会将每条数据转换成一个 Point，并按照 Point 的 series + field 分组。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Engine</span><span class=p>)</span> <span class=nf>WritePoints</span><span class=p>(</span><span class=nx>points</span> <span class=p>[]</span><span class=nx>models</span><span class=p>.</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>measurementFieldsToSave</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>tsdb</span><span class=p>.</span><span class=nx>MeasurementFields</span><span class=p>,</span> <span class=nx>seriesToCreate</span> <span class=p>[]</span><span class=o>*</span><span class=nx>tsdb</span><span class=p>.</span><span class=nx>SeriesCreate</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>key</span> <span class=o>:=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nf>Key</span><span class=p>())</span> <span class=o>+</span> <span class=nx>keyFieldSeparator</span> <span class=o>+</span> <span class=nx>k</span>
</span></span><span class=line><span class=cl>    <span class=nx>values</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>values</span><span class=p>[</span><span class=nx>key</span><span class=p>],</span> <span class=nf>NewValue</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nf>Time</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>(),</span> <span class=nx>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>这里的 <code>p</code> 是 point，<code>p.Key()</code> 是 measurement + series，<code>k</code> 是 field key。<code>values</code> 的类型是 <code>map[string][]Value</code></p></blockquote><p>每个分组的数据会分别加入到缓存里面。接着写一份到 WAL（Write Ahead Log，写日志） 文件里面，便于程序重启或崩溃后恢复内存数据。</p><blockquote><p>缓存里面包括原先存储在磁盘上的数据，这些数据会和后续新增的数据合并并且排序。</p></blockquote><p>然后对缓存中每个分组的数据执行压缩，压缩的结果是一个 Block。每个分组保存的是一个 Field 的数据，因此一个 Block 对应一个 Field。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>block</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>values</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的 <code>values</code> 的类型是 <code>[]Value</code>，即上面的那个 values 取其中一个 field 的分组。说明每个 block 存储的是一个 field 的数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────┬─────────┐
</span></span><span class=line><span class=cl>│  CRC    │  Data   │
</span></span><span class=line><span class=cl>│ 4 bytes │ N bytes │
</span></span><span class=line><span class=cl>└─────────┴─────────┘
</span></span></code></pre></td></tr></table></div></div><p>其中的 Data 部分有三个内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌───────────────────┬───────────────────┬───────────────────┐
</span></span><span class=line><span class=cl>│  first timestamp  │   all timestamp   │     all value     │
</span></span><span class=line><span class=cl>└───────────────────┴───────────────────┴───────────────────┘
</span></span></code></pre></td></tr></table></div></div><ol><li>Data 部分第一个数据的时间戳</li><li>所有数据的时间戳</li><li>所有数据的值</li></ol><p>这里的时间戳和它对应的值是分成两部分存储的。</p><p>接着计算这个 Block 的 CRC 校验码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>tsmWriter</span><span class=p>)</span> <span class=nf>WriteBlock</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>minTime</span><span class=p>,</span> <span class=nx>maxTime</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>block</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>checksum</span> <span class=p>[</span><span class=nx>crc32</span><span class=p>.</span><span class=nx>Size</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>PutUint32</span><span class=p>(</span><span class=nx>checksum</span><span class=p>[:],</span> <span class=nx>crc32</span><span class=p>.</span><span class=nf>ChecksumIEEE</span><span class=p>(</span><span class=nx>block</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>先写 CRC 校验码再写 Data。</p><p>写入 CRC 校验码之前会判断文件是否已经有内容，如果没有，则写入 Header。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    ↓ 这个部分
</span></span><span class=line><span class=cl>┌────────┬────────────────────────────────────┬─────────────┬──────────────┐
</span></span><span class=line><span class=cl>│ Header │               Blocks               │    Index    │    Footer    │
</span></span><span class=line><span class=cl>│5 bytes │              N bytes               │   N bytes   │   4 bytes    │
</span></span><span class=line><span class=cl>└────────┴────────────────────────────────────┴─────────────┴──────────────┘
</span></span></code></pre></td></tr></table></div></div><p>之后把这个 Block 的 【key（即 series + field）、field 的数据类型、时间段、该 Block 在文件的偏移量、该 Block 的长度】 添加到内存中的索引。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>t</span><span class=p>.</span><span class=nx>index</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>blockType</span><span class=p>,</span> <span class=nx>values</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nf>UnixNano</span><span class=p>(),</span> <span class=nx>values</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nf>UnixNano</span><span class=p>(),</span> <span class=nx>t</span><span class=p>.</span><span class=nx>n</span><span class=p>,</span> <span class=nb>uint32</span><span class=p>(</span><span class=nx>n</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>写完所有 Block 之后，再把索引写入到文件。之后把原先的 tsm 文件删掉。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                                                     ↓ 索引是这个部分
</span></span><span class=line><span class=cl>┌────────┬────────────────────────────────────┬─────────────┬──────────────┐
</span></span><span class=line><span class=cl>│ Header │               Blocks               │    Index    │    Footer    │
</span></span><span class=line><span class=cl>│5 bytes │              N bytes               │   N bytes   │   4 bytes    │
</span></span><span class=line><span class=cl>└────────┴────────────────────────────────────┴─────────────┴──────────────┘
</span></span></code></pre></td></tr></table></div></div><h2 id=连续查询continues-query>连续查询（Continues Query）</h2><p>连续查询是由 InfluxDB 按照一定时间间隔执行查询，并将结果插入到指定表中。</p><p>连续查询分为基础语法和高级语法。它们的区别在于对查询时间范围和两次查询的间隔的配置。</p><p>首先是基础语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</span></span><span class=line><span class=cl>BEGIN
</span></span><span class=line><span class=cl>  SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</span></span><span class=line><span class=cl>END
</span></span></code></pre></td></tr></table></div></div><p>基础语法的查询间隔为：<code>GROUP BY time()</code> 的 interval。即如果 interval 为 1m，则一分钟执行一次。</p><p>基础语法的查询时间范围为：执行查询的时间点 <code>now()</code> 减去 <code>GROUP BY time()</code> 的 interval。即 <code>WHERE time >= (now() - interval) AND time &lt; now()</code>。</p><p>高级语法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</span></span><span class=line><span class=cl>RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
</span></span><span class=line><span class=cl>BEGIN
</span></span><span class=line><span class=cl>  SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</span></span><span class=line><span class=cl>END
</span></span></code></pre></td></tr></table></div></div><p>高级语法比基础语法多了一行：<code>RESAMPLE EVERY &lt;interval> FOR &lt;interval></code></p><p>其中 EVERY 确定查询间隔，FOR 确定查询时间范围。其中一个可以不填，例如：</p><p><code>RESAMPLE EVERY &lt;interval></code> 或者 <code>RESAMPLE FOR &lt;interval></code>。</p><p>其中一个不填时，相当于自动把它的 interval 设置为 <code>GROUP BY time()</code> 的 interval。</p><p>当数据输入有延迟时，需要使用高级语法的 <code>FOR</code> 扩大查询范围。</p><p>例如聚合一分钟的数据需要延迟半分钟，那么将 <code>FOR</code> 设置为 2 分钟。这样就能在第三分钟开始的时候，查询第一和第二分钟的数据。由于第二分钟的数据需要再等半分钟才有，所以相当于是获取第一分钟的数据。</p><h2 id=写入>写入</h2><p><a href=https://docs.influxdata.com/influxdb/v1.8/guides/hardware_sizing/ target=_blank rel="noopener noreffer">https://docs.influxdata.com/influxdb/v1.8/guides/hardware_sizing/</a></p><p>单机写入的极限是每秒 75 万个字段。估算方法是一秒的 point 数量乘以一条数据的字段数量。point 数量可以从 <code>_internal</code> 库的 write 表的 pointReq 获取。字段数量可以执行 <code>show field keys</code> 获取。</p><p>在某些场景下，不是每一秒钟都有 75 万个字段，而是在每分钟内的某一秒会同时收到超过 75 万个字段的数据。这种情况要取这些数据在一分钟每秒的平均值。如果平均值不超过 75 万个字段，那么单机可以承受住。</p><p>也就是 InfluxDB 最多一分钟可以写 4500 万个字段，实际值可能会比这个小一些，可以通过业务数据测试实际负载。</p><h2 id=写入的优化>写入的优化</h2><p><a href=https://docs.influxdata.com/influxdb/v2.0/write-data/best-practices/optimize-writes/ target=_blank rel="noopener noreffer">https://docs.influxdata.com/influxdb/v2.0/write-data/best-practices/optimize-writes/</a></p><ol><li>使用 gzip 压缩</li><li>批量写，最理想的是一次 5000 行</li><li>转换为行的时候，按字典顺序排序 tag 的字段</li><li>设置最合适的时间精度。例如同一个 tag 不会有两条同一秒的数据，那么就把时间精度设置为秒级</li></ol><h2 id=series-file>Series File</h2><p><a href=https://www.jianshu.com/p/4e6fda6d6b63 target=_blank rel="noopener noreffer">https://www.jianshu.com/p/4e6fda6d6b63</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-03-06</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/2021/03/06/influxdb-read-write/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://schaepher.github.io/2021/03/06/influxdb-read-write/ data-title="InfluxDB 存储结构、读、写" data-hashtags=InfluxDB><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://schaepher.github.io/2021/03/06/influxdb-read-write/ data-hashtag=InfluxDB><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://schaepher.github.io/2021/03/06/influxdb-read-write/ data-title="InfluxDB 存储结构、读、写"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://schaepher.github.io/2021/03/06/influxdb-read-write/ data-title="InfluxDB 存储结构、读、写"><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://schaepher.github.io/2021/03/06/influxdb-read-write/ data-title="InfluxDB 存储结构、读、写"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://schaepher.github.io/2021/03/06/influxdb-read-write/ data-title="InfluxDB 存储结构、读、写"><i class="fab fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/influxdb/>InfluxDB</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2021/02/23/concurrency-parallelism-and-lock/ class=prev rel=prev title=并发、并行与锁><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>并发、并行与锁</a>
<a href=/2021/03/06/pcb/ class=next rel=next title=快速了解线路板（PCB）基础知识>快速了解线路板（PCB）基础知识<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://cnblogs.com/schaepher target=_blank>Schaepher</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>