<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>MySQL - 标签 - Schaepher's Blog</title><link>https://schaepher.github.io/tags/mysql/</link><description>MySQL - 标签 - Schaepher's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>schaepher@outlook.com (Schaepher)</managingEditor><webMaster>schaepher@outlook.com (Schaepher)</webMaster><lastBuildDate>Tue, 14 Jun 2022 11:10:00 +0000</lastBuildDate><atom:link href="https://schaepher.github.io/tags/mysql/" rel="self" type="application/rss+xml"/><item><title>MySQL InnoDB 并发控制之 MVCC</title><link>https://schaepher.github.io/2022/06/14/mysql-mvcc/</link><pubDate>Tue, 14 Jun 2022 11:10:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2022/06/14/mysql-mvcc/</guid><description>MySQL 的多版本并发控制（Multiversion Concurrency Control，MVCC）解决了 InnoDB 事务隔离级别中读已提交和可重复读的读和写冲突问题。MVCC 使</description></item><item><title>事务</title><link>https://schaepher.github.io/drafts/transaction/transaction/</link><pubDate>Tue, 14 Jun 2022 11:10:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/drafts/transaction/transaction/</guid><description>在读+写不是一个原子操作的时候，为了提高处理速度而引入的并发访问会使得一些读写操作的结果不符合预期。由于数据库读取数据时的最小粒度是数据页，</description></item><item><title>MySQL 创建辅助索引的底层过程</title><link>https://schaepher.github.io/2020/04/30/mysql-index-creation/</link><pubDate>Thu, 30 Apr 2020 12:39:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/04/30/mysql-index-creation/</guid><description>执行 ALTER 创建索引的时候， MySQL 的处理过程是怎么样的呢？ MySQL 5.5 之前（默认使用 MyISAM 作为存储引擎） 过程： 取旧表 ALTER TABLE 后的结构，以该结构创建临时表 原表加写锁，原</description></item><item><title>MySQL 自增主键</title><link>https://schaepher.github.io/2020/04/28/mysql-auto-inc/</link><pubDate>Tue, 28 Apr 2020 21:16:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/04/28/mysql-auto-inc/</guid><description>原文： MySQL 自增主键 https://schaepher.github.io/2020/04/28/mysql-auto-inc/ 以下仅考虑 InnoDB 存储引擎。 自增主键有两个性质需要考虑： 单调性 每次插入一条数据，其 ID 都是比上一条插入的数据的 ID 大，就算上一条数据</description></item><item><title>MySQL 主从延迟监控</title><link>https://schaepher.github.io/drafts/mysql-slave-delay-monitor/mysql-slave-delay-monitor/</link><pubDate>Tue, 21 Apr 2020 00:18:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/drafts/mysql-slave-delay-monitor/mysql-slave-delay-monitor/</guid><description></description></item><item><title>Mariadb 授权与回收</title><link>https://schaepher.github.io/2019/08/18/mysql-grant/</link><pubDate>Sun, 18 Aug 2019 11:29:22 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2019/08/18/mysql-grant/</guid><description><![CDATA[创建用户 1 CREATE USER &#34;username&#34;@&#34;host&#34; IDENTIFIED BY &#39;password&#39;; 授权 1 GRANT ALL PRIVILEGES ON dbname.* TO &#34;username&#34;@&#34;host&#34;; 回收 1 REVOKE ALL PRIVILEGES ON dbname.* FROM &#34;username&#34;@&#34;host&#34;;]]></description></item><item><title>记一个 SQL 导致的问题的处理</title><link>https://schaepher.github.io/2019/08/15/mysql-and-error/</link><pubDate>Thu, 15 Aug 2019 23:00:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2019/08/15/mysql-and-error/</guid><description>背景 我们组负责维护一个内部系统，这个系统里面有一个功能：允许管理员在上面执行 SQL 语句，没有任何限制。 14 号下午，同事在这个系统的生产环境执行了一</description></item></channel></rss>