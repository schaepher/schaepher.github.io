<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>PHP - 标签 - Schaepher's Blog</title><link>https://schaepher.github.io/tags/php/</link><description>PHP - 标签 - Schaepher's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>schaepher@outlook.com (Schaepher)</managingEditor><webMaster>schaepher@outlook.com (Schaepher)</webMaster><lastBuildDate>Wed, 29 Apr 2020 12:41:00 +0000</lastBuildDate><atom:link href="https://schaepher.github.io/tags/php/" rel="self" type="application/rss+xml"/><item><title>PHP 语言使用细节</title><link>https://schaepher.github.io/2020/04/29/php-detail/</link><pubDate>Wed, 29 Apr 2020 12:41:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/04/29/php-detail/</guid><description>array_merge() 、array_combine() 和 + 处理 key 冲突的区别 操作 数字 key 字符串 key array_merge 自增 覆盖已存在值 + 使用已存在值 使用已存在值 array_combine 覆盖已存在值 覆盖已存在</description></item><item><title>编译和调试 PHP</title><link>https://schaepher.github.io/2020/04/01/php-compile/</link><pubDate>Wed, 01 Apr 2020 21:00:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/04/01/php-compile/</guid><description><![CDATA[编译 基本上按照官方的来就行了： https://github.com/Microsoft/php-sdk-binary-tools 1 2 3 4 5 6 7 8 git clone https://github.com/Microsoft/php-sdk-binary-tools.git c:\php-sdk cd c:\php-sdk git checkout php-sdk-2.2.0 ./phpsdk-vc15-x64.bat phpsdk_buildtree phpmaster git clone https://github.com/php/php-src.git &amp;&amp; cd php-src phpsdk_deps --update --branch 7.4 buildconf &amp;&amp; configure --enable-cli &amp;&amp; nmake 注意 phpsdk_deps --update --branch 7.4 这一个命令。官方例子是 m]]></description></item><item><title>【PHP 源码】PHP 函数调用</title><link>https://schaepher.github.io/2020/03/30/php-function-call/</link><pubDate>Mon, 30 Mar 2020 23:25:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/30/php-function-call/</guid><description>想法 我以前对于 C 语言的印象是有很强的确定性，而 PHP 在执行的时候会被翻译为 C 语言执行，所以一直很好奇 PHP 怎么调用底层函数。 换句话说就是已知函数名字</description></item><item><title>【PHP 源码】PHP 函数注册</title><link>https://schaepher.github.io/2020/03/30/php-function-regist/</link><pubDate>Mon, 30 Mar 2020 23:25:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/30/php-function-regist/</guid><description>函数的注册 调用顺序为： 1 2 3 4 5 6 7 - main -- php_cli_startup --- php_module_startup ---- zend_startup ----- zend_startup_builtin_function ------ zend_register_module_ex(*module) ------- zend_register_functions(module-&amp;gt;functions) sapi/cli/php_cli.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main(int argc, char *argv[]) { // ... sapi_module_struct *sapi_module = &amp;amp;cli_sapi_module; // ... /* startup after we get the</description></item><item><title>PHP sort 源码</title><link>https://schaepher.github.io/2020/03/30/php-sort/</link><pubDate>Mon, 30 Mar 2020 23:25:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/30/php-sort/</guid><description>ext/standard/array.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* {{{ proto bool sort(array &amp;amp;array_arg [, int sort_flags]) Sort an array */ PHP_FUNCTION(sort) { zval *array; zend_long sort_type = PHP_SORT_REGULAR; compare_func_t cmp; ZEND_PARSE_PARAMETERS_START(1, 2) Z_PARAM_ARRAY_EX(array, 0, 1) Z_PARAM_OPTIONAL Z_PARAM_LONG(sort_type) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); cmp = php_get_data_compare_func(sort_type, 0); // 根据 sort_flags 选择比较函数 if (zend_hash_sort(Z_ARRVAL_P(array), cmp,</description></item><item><title>阅读 PHP 源码</title><link>https://schaepher.github.io/2020/03/30/read-php-src/</link><pubDate>Mon, 30 Mar 2020 23:25:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/30/read-php-src/</guid><description>从数组入手。 数组相关函数是 PHP 扩展的一部分，扩展名为 standard，执行 php -m 可以看到该扩展。 该扩展的源码在 PHP 源码包的 ext/standard ，其中数组相关函数的定</description></item><item><title>PHP 对象</title><link>https://schaepher.github.io/2020/03/30/php-object/</link><pubDate>Mon, 30 Mar 2020 12:49:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/30/php-object/</guid><description>创建对象： zend_objects.c 1 2 3 4 5 6 7 8 ZEND_API zend_object* ZEND_FASTCALL zend_objects_new(zend_class_entry *ce) { zend_object *object = emalloc(sizeof(zend_object) + zend_object_properties_size(ce)); _zend_object_std_init(object, ce); object-&amp;gt;handlers = &amp;amp;std_object_handlers; return object; } zend_object_handlers.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ZEND_API const</description></item><item><title>PHP 垃圾回收</title><link>https://schaepher.github.io/2020/03/30/php-gc/</link><pubDate>Mon, 30 Mar 2020 12:49:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/30/php-gc/</guid><description>每个值容器（zend_value）里面都会有引用计数结构体 zend_rrefcounted 引用计数减少到 0 时进行清除 unset() 将值的引用减少 1 值容器引用在减少 1 后如果不为 0 ，则加</description></item><item><title>内存分配器</title><link>https://schaepher.github.io/2020/03/23/memory-allocation/</link><pubDate>Mon, 23 Mar 2020 23:46:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/23/memory-allocation/</guid><description>传统的内存分配和现代的内存分配 传统的内存分配是在需要内存的时候使用 malloc() 函数直接向操作系统申请内存，在释放内存的时候用 free() 把内存还给操作系统。 malloc =</description></item><item><title>【数据结构】Map （映射）的各种实现</title><link>https://schaepher.github.io/2020/03/15/map/</link><pubDate>Sun, 15 Mar 2020 16:59:00 +0000</pubDate><author>Schaepher</author><guid>https://schaepher.github.io/2020/03/15/map/</guid><description>In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection. —— wikipedia 在计算机科学中，关联数组、映射、符号表或者字典是一种由一系列(</description></item></channel></rss>