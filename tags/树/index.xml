<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>树 - 标签 - Schaepher's Blog</title><link>https://schaepher.github.io/tags/%E6%A0%91/</link><description>树 - 标签 - Schaepher's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 11 Jun 2022 12:26:00 +0000</lastBuildDate><atom:link href="https://schaepher.github.io/tags/%E6%A0%91/" rel="self" type="application/rss+xml"/><item><title>红黑树</title><link>https://schaepher.github.io/2022/06/11/red-black-tree/</link><pubDate>Sat, 11 Jun 2022 12:26:00 +0000</pubDate><author>xxxx</author><guid>https://schaepher.github.io/2022/06/11/red-black-tree/</guid><description><![CDATA[<p>2-3 树和 2-3-4 树统称为 B-树（Balanced Tree）。</p>
<h3 id="为什么不直接使用-b-树">为什么不直接使用 B-树？</h3>
<p>既然以 2-3 树和 2-3-4 树都可以用来转换成红黑树，为什么最终使用 2-3-4 树的转换呢？</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/8765558/why-dont-we-use-2-3-or-2-3-4-5-trees" target="_blank" rel="noopener noreffer ">https://stackoverflow.com/questions/8765558/why-dont-we-use-2-3-or-2-3-4-5-trees</a></p></blockquote>
<blockquote>
<p>Implementation of 2-3-4 trees typically requires either multiple classes (2NODE, 3NODE, 4NODE) or you have just NODE that has an array of items. In the case of multiple classes you waste lots of time constructing and destructing node instances and reparenting them is cumbersome. If you use a single class with arrays to hold items and children then you are either resizing arrays constantly which is similarly wasteful or you wind up wasting over half your memory on unused array elements. It&rsquo;s just not very efficient compared to Red-Black trees.</p>]]></description></item><item><title>2-3树 —— 理解红黑树的捷径</title><link>https://schaepher.github.io/2022/06/02/2-3-tree/</link><pubDate>Thu, 02 Jun 2022 12:26:00 +0000</pubDate><author>xxxx</author><guid>https://schaepher.github.io/2022/06/02/2-3-tree/</guid><description>&lt;p>如果从先易后难的顺序介绍各种树，那么红黑树必然放在 AVL 树后面。但在红黑树之前，还有一种名为 2-3 树的平衡二叉树。2-3 树理解起来比红黑树容易很多，并且在理解它的基础上增加一个变更，就成了红黑树（尽管不是通常使用的那种红黑树）。因此学习红黑树的时候，最好先学习 2-3 树。&lt;/p></description></item><item><title>打印二叉树</title><link>https://schaepher.github.io/2022/06/01/print-binary-tree/</link><pubDate>Wed, 01 Jun 2022 18:50:00 +0000</pubDate><author>xxxx</author><guid>https://schaepher.github.io/2022/06/01/print-binary-tree/</guid><description><![CDATA[<h2 id="背景">背景</h2>
<p>之前在了解二叉树旋转的时候，为了方便查看中间状态，就写了个以树状形式打印二叉树的函数。</p>
<p>起初是使用二叉树中序遍历的结果展开的方式，简单但打印出来的树有一定的倾斜。</p>]]></description></item><item><title>平衡二叉树</title><link>https://schaepher.github.io/2022/05/30/balanced-binary-tree/</link><pubDate>Mon, 30 May 2022 15:15:00 +0000</pubDate><author>xxxx</author><guid>https://schaepher.github.io/2022/05/30/balanced-binary-tree/</guid><description>&lt;p>上一篇把树旋转了解清楚，是为这一篇平衡二叉树准备的。&lt;/p>
&lt;p>平衡二叉树，就是在二叉树的基础上加上一个条件：对于任意节点，左子树和右子树的树高之差不超过 1。&lt;/p></description></item><item><title>因为一句话，秒懂二叉树旋转</title><link>https://schaepher.github.io/2022/05/11/tree-rotation/</link><pubDate>Wed, 11 May 2022 12:30:00 +0000</pubDate><author>xxxx</author><guid>https://schaepher.github.io/2022/05/11/tree-rotation/</guid><description><![CDATA[<p>事情要从某天晚上买夜宵说起。买了香肠拿着吃，想着多年来一直没搞懂的树旋转是不是应该看看，就点进某百科。</p>
<blockquote>
<p>树旋转是在二叉树中的一种子树调整操作， 每一次旋转并不影响对该二叉树进行中序遍历的结果。</p>]]></description></item></channel></rss>